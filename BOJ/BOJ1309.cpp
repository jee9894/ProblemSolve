/****************************************************************************
						jee9894's Problem Solve Study
=============================================================================
		Problem Name       : 동물원
		Problem Number     : 1309
		algorithm          : dynamic programming
=============================================================================
		History
		---------------------------------------------------------------------
		jee9894 : 2019.12.11 create
		----------------------------------------------------------------------
=============================================================================
		Note.
****************************************************************************/
#include <iostream>

using namespace std;

#define MAX_SIZE 100001
#define MODULER 9901

// [최대 줄 갯수][3가지 경우의 수]
// 경우의 수
// 1. 해당줄에 사자를 배치하지 않은 경우
// 2. 해당줄의 왼쪽칸에 사자를 배치한 경우
// 3. 해당줄의 오른쪽칸에 사자를 배치한 경우
unsigned int fence[MAX_SIZE][3];

void MakeFence(int n)
{
	for (int i = 2; i <= n; ++i)
	{
		// n번째줄에 아무것도 배치하지 않는 경우의 수 == n-1번째 줄에 1,2,3번의 경우의 수 총합
		fence[i][0] = (fence[i - 1][0] + fence[i - 1][1] + fence[i - 1][2]) % MODULER;
		// n번째줄에 왼쪽에만 배치하는 경우의 수 == n-1번째 줄에 1,3번의 경우의 수 총합
		fence[i][1] = (fence[i - 1][0] + fence[i - 1][2]) % MODULER;
		// n번째줄에 오른쪽에만 배치하는 경우의 수 == n-1번째 줄에 1,2번의 경우의 수 총합
		fence[i][2] = (fence[i - 1][0] + fence[i - 1][1]) % MODULER;
	}
}

int main()
{
	int num;
	cin >> num;
	// 첫번째 줄에는 각각 1개의 경우만 존재 -> 초기값
	fence[1][0] = fence[1][1] = fence[1][2] = 1;
	MakeFence(num);
	// 모든 경우의 수 == n번째줄의 1,2,3번 경우의 수 총합
	cout << (fence[num][0] + fence[num][1] + fence[num][2]) % MODULER << endl;
}
